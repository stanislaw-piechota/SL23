<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>main API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>main</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import algorithm as alg
import pygame
from constants import *
from random import choice
from sys import exit


class Controller():
    &#34;&#34;&#34;
    Class holding and controlling positions of all objects displayed on the screen
    And control all events of the game.

    It&#39;s main purpose is to share screen, and event bools i.e. raft_animation
    &#34;&#34;&#34;
    def __init__(self, screen: pygame.surface.Surface):
        self.screen = screen
        self.game_running = False
        self.initialise_game()
        self.animated_figure = None
        self.raft_animation = False

    def rand_not_colliding_rect(self, side):
        &#34;&#34;&#34;
        Rand a position on adequate side of the river which isn&#39;t occupied by other figure
        &#34;&#34;&#34;
        width, height = CANNIBAL.get_width(), MISSIONARY.get_height()
        if side == &#34;&lt;&#34;:
            xs = [i*width for i in range(LEFT_WIDTH//width)]
            ys = [SCREEN_HEIGHT-LEFT_HEIGHT+i*height for i in range(LEFT_HEIGHT//height)]
        else:
            xs = [SCREEN_WIDTH-RIGHT_WIDTH+i*width for i in range(RIGHT_WIDTH//width)]
            ys = [SCREEN_HEIGHT-RIGHT_HEIGHT+i*height for i in range(RIGHT_HEIGHT//height)]
        # missionary is higher than cannibal
        # cannibal is wider than missionary
        new_rect = pygame.Rect(choice(xs), choice(ys), CANNIBAL.get_width(), MISSIONARY.get_height())
        while new_rect.collidelist([x[&#34;rect&#34;] for x in self.cannibals+self.missionaries]) &gt;= 0:
            new_rect.topleft = (choice(xs), choice(ys))
        return new_rect

    def update_hint(self):
        &#34;&#34;&#34;
        Update counter of moves, check the current minimum according to new path
        and render new text with the resulting value
        &#34;&#34;&#34;
        self.moves_count += 1
        currrent_min_moves = min([len(x) for x in alg.find_path(self.position, [self.position], alg.winning)])-1
        self.moves_render = FONT.render(HINT_TEXT.format(currrent_min_moves), True, TEXT_COLOR)

    def initialise_game(self):
        &#34;&#34;&#34;
        Create / reset neccessary basic attributes of the game
        &#34;&#34;&#34;
        self.position = alg.starting
        self.win = None
        self.cannibals, self.missionaries = [], []
        for _ in range(CHARACTERS_NUMBER):
            self.cannibals.append({
                &#34;rect&#34;: self.rand_not_colliding_rect(STARTING_SIDE),
                &#34;type&#34;: &#34;c&#34;,
                &#34;side&#34;: STARTING_SIDE,
                &#34;state&#34;: &#34;edge&#34;
            })
            self.missionaries.append({
                &#34;rect&#34;: self.rand_not_colliding_rect(STARTING_SIDE),
                &#34;type&#34;: &#34;m&#34;,
                &#34;side&#34;: STARTING_SIDE,
                &#34;state&#34;: &#34;edge&#34;
            })
        self.raft_rect = RAFT.get_rect(topleft=self.get_raft_position())
        self.raft_count = 0
        self.raft_crew = []
        self.minimum_moves = min([len(x) for x in alg.find_path(self.position, [self.position], alg.winning)])-1
        self.moves_count = -1
        self.update_hint()

    def update_screen(self):
        &#34;&#34;&#34;
        Display objects according to current phase of the game
        &#34;&#34;&#34;
        self.screen.blit(BACKGROUND, BACKGROUND.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2)))
        if self.game_running:
            if self.raft_animation:
                self.animate_raft()
            if self.animated_figure:
                self.transfer_figure()
            for i in range(CHARACTERS_NUMBER):
                self.screen.blit(CANNIBAL, self.cannibals[i][&#34;rect&#34;])
                self.screen.blit(MISSIONARY, self.missionaries[i][&#34;rect&#34;])
            self.screen.blit(RAFT, self.raft_rect)
            self.screen.blit(self.moves_render, self.moves_render.get_rect(center=(SCREEN_WIDTH//2, 50)))
        else:
            # game not started
            if not isinstance(self.win, bool):
                self.screen.blit(STARTING_TEXT, STARTING_TEXT.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2)))
            else:
                # game won
                if self.win:
                    self.screen.blit(WIN_TEXT, WIN_TEXT.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2)))
                # game lost
                else:
                    self.screen.blit(LOSING_TEXT, LOSING_TEXT.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2)))
                self.screen.blit(self.moves_render, self.moves_render.get_rect(center=(SCREEN_WIDTH//2, 50)))
        pygame.display.flip()

    def calculate_direction(self):
        &#34;&#34;&#34;
        Get current position of the raft and its side
        And calculate the direction of movement of the raft
        &#34;&#34;&#34;
        sign = alg.split_position(self.position)[2]
        if sign == &#34;&lt;&#34;:
            self.side_index = 0
        else:
            self.side_index = 1
        self.opposite_index = 1-self.side_index
        self.direction = self.opposite_index - self.side_index

    def animate_raft(self):
        &#34;&#34;&#34;
        Animate raft and objects on it aka raft crew
        &#34;&#34;&#34;
        # when the expression reaches 0 it means the raft came to the right place
        if self.direction * (RAFT_POSITIONS[self.opposite_index][0]-self.raft_rect.x) &gt; 0:
            self.raft_rect.x += self.direction * RAFT_SPEED
            for figure in self.raft_crew:
                figure[&#34;rect&#34;].x += self.direction * RAFT_SPEED
        else:
            # raft on the other side
            # stop animation and update position
            self.raft_rect.x = RAFT_POSITIONS[self.opposite_index][0]
            self.raft_animation = False
            # as raft reached other side it can be considered as move completion
            self.update_position()

    def get_raft_position(self):
        &#34;&#34;&#34;
        Get raft destination position according to side
        &#34;&#34;&#34;
        sign = alg.split_position(self.position)[2]

        if sign == &#34;&lt;&#34;:
            return RAFT_POSITIONS[0]
        return RAFT_POSITIONS[1]

    def calculate_velocity(self):
        &#34;&#34;&#34;
        Calculate new position of each figure after changing place
        And the speed it needs to maintain to reach the position in
        certain number of frames (ANIMATION_STEPS)
        &#34;&#34;&#34;
        # calculate position when figure is reqiestered as raft crew
        if self.animated_figure[&#34;state&#34;] == &#34;raft&#34;:
            new_left, new_bottom = self.rand_not_colliding_rect(alg.split_position(self.position)[2]).bottomleft
        else:
            crew_xs = [x[&#34;rect&#34;].left for x in self.raft_crew]
            # take first empty place on the raft
            for i in range(RAFT_CAPACITY):
                new_left = self.raft_rect.left + i * CANNIBAL.get_width()
                if new_left not in crew_xs:
                    break
            new_bottom = self.raft_rect.bottom
        # derivates of velocities
        self.dx = (new_left-self.animated_figure[&#34;rect&#34;].left)/ANIMATION_STEPS
        self.dy = (new_bottom-self.animated_figure[&#34;rect&#34;].bottom)/ANIMATION_STEPS
        self.animation_step = 0
        # dx and dy are often &lt; 1 and wouldn&#39;t be registered when assigned to rect
        # so 3rd variable of float type is used to store actual position
        self.animated_figure_x, self.animated_figure_y = self.animated_figure[&#34;rect&#34;].bottomleft

    def transfer_figure(self):
        &#34;&#34;&#34;
        Function to animate each figure
        &#34;&#34;&#34;
        # limit of slots on the raft
        if self.raft_count &gt;= RAFT_CAPACITY and\
                self.animated_figure not in self.raft_crew:
            self.animated_figure = None
            return
        # animation came to an end
        if self.animation_step == ANIMATION_STEPS:
            # figure switches from side to raft
            if self.animated_figure[&#34;state&#34;] == &#34;edge&#34;:
                self.animated_figure[&#34;state&#34;] = &#34;raft&#34;
                self.raft_crew.append(self.animated_figure)
                self.raft_count += 1
            # antagonistic case
            else:
                self.animated_figure[&#34;state&#34;] = &#34;edge&#34;
                self.raft_crew.remove(self.animated_figure)
                self.raft_count -= 1
            self.animated_figure = None
            return

        self.animated_figure_x += self.dx
        self.animated_figure_y += self.dy
        self.animated_figure[&#34;rect&#34;].bottomleft = (self.animated_figure_x, self.animated_figure_y)
        self.animation_step += 1

    def update_position(self):
        &#34;&#34;&#34;
        Updates position after move is completed, checks for victory or lose
        and takes care of updating hint text
        &#34;&#34;&#34;
        raft_crew_types = [x[&#34;type&#34;] for x in self.raft_crew]
        raft_string = &#39;&#39;.join(sorted(raft_crew_types))
        self.position = alg.get_resulting_position(self.position, raft_string)
        new_sign = alg.split_position(self.position)[2]
        for figure in self.raft_crew:
            figure[&#34;side&#34;] = new_sign
        if self.position == alg.winning:
            self.win = True
            self.game_running = False
            self.moves_count += 1
            self.moves_render = FONT.render(FINAL_TEXT.format(self.moves_count, self.minimum_moves), True, TEXT_COLOR)
            return
        elif self.position in alg.losing:
            self.win = False
            self.game_running = False
            self.moves_count += 1
            self.moves_render = FONT.render(FINAL_TEXT.format(self.moves_count, self.minimum_moves), True, TEXT_COLOR)
            return
        self.update_hint()

    def check_events(self):
        &#34;&#34;&#34;
        Checks for input of the player and reacts adequately
        Because of all the animations it doesn&#39;t call functions but sets event variables
        &#34;&#34;&#34;
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                exit()
            elif event.type == pygame.KEYDOWN:
                if not self.game_running:
                    self.game_running = True
                    self.initialise_game()
            # 2nd and 3rd condition are disabling few animations onging at one moment
            elif event.type == pygame.MOUSEBUTTONDOWN and not self.raft_animation and not self.animated_figure:
                # player not allowed to control game when its not started
                if not self.game_running:
                    return
                if self.raft_rect.collidepoint(event.pos) and self.raft_count &gt;= 1:
                    self.raft_animation = True
                    self.calculate_direction()

                    continue
                for figure in self.cannibals+self.missionaries:
                    if figure[&#34;rect&#34;].collidepoint(event.pos) and\
                        alg.split_position(self.position)[2] == figure[&#34;side&#34;] and\
                            not self.animated_figure:
                        self.animated_figure = figure
                        self.calculate_velocity()


def run_game():
    pygame.init()
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    pygame.display.set_caption(&#34;Missionaries and cannibals&#34;)
    clock = pygame.time.Clock()
    controller = Controller(screen)

    while True:
        controller.check_events()
        controller.update_screen()
        clock.tick(FPS)


if __name__ == &#34;__main__&#34;:
    run_game()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="main.run_game"><code class="name flex">
<span>def <span class="ident">run_game</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_game():
    pygame.init()
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    pygame.display.set_caption(&#34;Missionaries and cannibals&#34;)
    clock = pygame.time.Clock()
    controller = Controller(screen)

    while True:
        controller.check_events()
        controller.update_screen()
        clock.tick(FPS)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="main.Controller"><code class="flex name class">
<span>class <span class="ident">Controller</span></span>
<span>(</span><span>screen:Â pygame.surface.Surface)</span>
</code></dt>
<dd>
<div class="desc"><p>Class holding and controlling positions of all objects displayed on the screen
And control all events of the game.</p>
<p>It's main purpose is to share screen, and event bools i.e. raft_animation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Controller():
    &#34;&#34;&#34;
    Class holding and controlling positions of all objects displayed on the screen
    And control all events of the game.

    It&#39;s main purpose is to share screen, and event bools i.e. raft_animation
    &#34;&#34;&#34;
    def __init__(self, screen: pygame.surface.Surface):
        self.screen = screen
        self.game_running = False
        self.initialise_game()
        self.animated_figure = None
        self.raft_animation = False

    def rand_not_colliding_rect(self, side):
        &#34;&#34;&#34;
        Rand a position on adequate side of the river which isn&#39;t occupied by other figure
        &#34;&#34;&#34;
        width, height = CANNIBAL.get_width(), MISSIONARY.get_height()
        if side == &#34;&lt;&#34;:
            xs = [i*width for i in range(LEFT_WIDTH//width)]
            ys = [SCREEN_HEIGHT-LEFT_HEIGHT+i*height for i in range(LEFT_HEIGHT//height)]
        else:
            xs = [SCREEN_WIDTH-RIGHT_WIDTH+i*width for i in range(RIGHT_WIDTH//width)]
            ys = [SCREEN_HEIGHT-RIGHT_HEIGHT+i*height for i in range(RIGHT_HEIGHT//height)]
        # missionary is higher than cannibal
        # cannibal is wider than missionary
        new_rect = pygame.Rect(choice(xs), choice(ys), CANNIBAL.get_width(), MISSIONARY.get_height())
        while new_rect.collidelist([x[&#34;rect&#34;] for x in self.cannibals+self.missionaries]) &gt;= 0:
            new_rect.topleft = (choice(xs), choice(ys))
        return new_rect

    def update_hint(self):
        &#34;&#34;&#34;
        Update counter of moves, check the current minimum according to new path
        and render new text with the resulting value
        &#34;&#34;&#34;
        self.moves_count += 1
        currrent_min_moves = min([len(x) for x in alg.find_path(self.position, [self.position], alg.winning)])-1
        self.moves_render = FONT.render(HINT_TEXT.format(currrent_min_moves), True, TEXT_COLOR)

    def initialise_game(self):
        &#34;&#34;&#34;
        Create / reset neccessary basic attributes of the game
        &#34;&#34;&#34;
        self.position = alg.starting
        self.win = None
        self.cannibals, self.missionaries = [], []
        for _ in range(CHARACTERS_NUMBER):
            self.cannibals.append({
                &#34;rect&#34;: self.rand_not_colliding_rect(STARTING_SIDE),
                &#34;type&#34;: &#34;c&#34;,
                &#34;side&#34;: STARTING_SIDE,
                &#34;state&#34;: &#34;edge&#34;
            })
            self.missionaries.append({
                &#34;rect&#34;: self.rand_not_colliding_rect(STARTING_SIDE),
                &#34;type&#34;: &#34;m&#34;,
                &#34;side&#34;: STARTING_SIDE,
                &#34;state&#34;: &#34;edge&#34;
            })
        self.raft_rect = RAFT.get_rect(topleft=self.get_raft_position())
        self.raft_count = 0
        self.raft_crew = []
        self.minimum_moves = min([len(x) for x in alg.find_path(self.position, [self.position], alg.winning)])-1
        self.moves_count = -1
        self.update_hint()

    def update_screen(self):
        &#34;&#34;&#34;
        Display objects according to current phase of the game
        &#34;&#34;&#34;
        self.screen.blit(BACKGROUND, BACKGROUND.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2)))
        if self.game_running:
            if self.raft_animation:
                self.animate_raft()
            if self.animated_figure:
                self.transfer_figure()
            for i in range(CHARACTERS_NUMBER):
                self.screen.blit(CANNIBAL, self.cannibals[i][&#34;rect&#34;])
                self.screen.blit(MISSIONARY, self.missionaries[i][&#34;rect&#34;])
            self.screen.blit(RAFT, self.raft_rect)
            self.screen.blit(self.moves_render, self.moves_render.get_rect(center=(SCREEN_WIDTH//2, 50)))
        else:
            # game not started
            if not isinstance(self.win, bool):
                self.screen.blit(STARTING_TEXT, STARTING_TEXT.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2)))
            else:
                # game won
                if self.win:
                    self.screen.blit(WIN_TEXT, WIN_TEXT.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2)))
                # game lost
                else:
                    self.screen.blit(LOSING_TEXT, LOSING_TEXT.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2)))
                self.screen.blit(self.moves_render, self.moves_render.get_rect(center=(SCREEN_WIDTH//2, 50)))
        pygame.display.flip()

    def calculate_direction(self):
        &#34;&#34;&#34;
        Get current position of the raft and its side
        And calculate the direction of movement of the raft
        &#34;&#34;&#34;
        sign = alg.split_position(self.position)[2]
        if sign == &#34;&lt;&#34;:
            self.side_index = 0
        else:
            self.side_index = 1
        self.opposite_index = 1-self.side_index
        self.direction = self.opposite_index - self.side_index

    def animate_raft(self):
        &#34;&#34;&#34;
        Animate raft and objects on it aka raft crew
        &#34;&#34;&#34;
        # when the expression reaches 0 it means the raft came to the right place
        if self.direction * (RAFT_POSITIONS[self.opposite_index][0]-self.raft_rect.x) &gt; 0:
            self.raft_rect.x += self.direction * RAFT_SPEED
            for figure in self.raft_crew:
                figure[&#34;rect&#34;].x += self.direction * RAFT_SPEED
        else:
            # raft on the other side
            # stop animation and update position
            self.raft_rect.x = RAFT_POSITIONS[self.opposite_index][0]
            self.raft_animation = False
            # as raft reached other side it can be considered as move completion
            self.update_position()

    def get_raft_position(self):
        &#34;&#34;&#34;
        Get raft destination position according to side
        &#34;&#34;&#34;
        sign = alg.split_position(self.position)[2]

        if sign == &#34;&lt;&#34;:
            return RAFT_POSITIONS[0]
        return RAFT_POSITIONS[1]

    def calculate_velocity(self):
        &#34;&#34;&#34;
        Calculate new position of each figure after changing place
        And the speed it needs to maintain to reach the position in
        certain number of frames (ANIMATION_STEPS)
        &#34;&#34;&#34;
        # calculate position when figure is reqiestered as raft crew
        if self.animated_figure[&#34;state&#34;] == &#34;raft&#34;:
            new_left, new_bottom = self.rand_not_colliding_rect(alg.split_position(self.position)[2]).bottomleft
        else:
            crew_xs = [x[&#34;rect&#34;].left for x in self.raft_crew]
            # take first empty place on the raft
            for i in range(RAFT_CAPACITY):
                new_left = self.raft_rect.left + i * CANNIBAL.get_width()
                if new_left not in crew_xs:
                    break
            new_bottom = self.raft_rect.bottom
        # derivates of velocities
        self.dx = (new_left-self.animated_figure[&#34;rect&#34;].left)/ANIMATION_STEPS
        self.dy = (new_bottom-self.animated_figure[&#34;rect&#34;].bottom)/ANIMATION_STEPS
        self.animation_step = 0
        # dx and dy are often &lt; 1 and wouldn&#39;t be registered when assigned to rect
        # so 3rd variable of float type is used to store actual position
        self.animated_figure_x, self.animated_figure_y = self.animated_figure[&#34;rect&#34;].bottomleft

    def transfer_figure(self):
        &#34;&#34;&#34;
        Function to animate each figure
        &#34;&#34;&#34;
        # limit of slots on the raft
        if self.raft_count &gt;= RAFT_CAPACITY and\
                self.animated_figure not in self.raft_crew:
            self.animated_figure = None
            return
        # animation came to an end
        if self.animation_step == ANIMATION_STEPS:
            # figure switches from side to raft
            if self.animated_figure[&#34;state&#34;] == &#34;edge&#34;:
                self.animated_figure[&#34;state&#34;] = &#34;raft&#34;
                self.raft_crew.append(self.animated_figure)
                self.raft_count += 1
            # antagonistic case
            else:
                self.animated_figure[&#34;state&#34;] = &#34;edge&#34;
                self.raft_crew.remove(self.animated_figure)
                self.raft_count -= 1
            self.animated_figure = None
            return

        self.animated_figure_x += self.dx
        self.animated_figure_y += self.dy
        self.animated_figure[&#34;rect&#34;].bottomleft = (self.animated_figure_x, self.animated_figure_y)
        self.animation_step += 1

    def update_position(self):
        &#34;&#34;&#34;
        Updates position after move is completed, checks for victory or lose
        and takes care of updating hint text
        &#34;&#34;&#34;
        raft_crew_types = [x[&#34;type&#34;] for x in self.raft_crew]
        raft_string = &#39;&#39;.join(sorted(raft_crew_types))
        self.position = alg.get_resulting_position(self.position, raft_string)
        new_sign = alg.split_position(self.position)[2]
        for figure in self.raft_crew:
            figure[&#34;side&#34;] = new_sign
        if self.position == alg.winning:
            self.win = True
            self.game_running = False
            self.moves_count += 1
            self.moves_render = FONT.render(FINAL_TEXT.format(self.moves_count, self.minimum_moves), True, TEXT_COLOR)
            return
        elif self.position in alg.losing:
            self.win = False
            self.game_running = False
            self.moves_count += 1
            self.moves_render = FONT.render(FINAL_TEXT.format(self.moves_count, self.minimum_moves), True, TEXT_COLOR)
            return
        self.update_hint()

    def check_events(self):
        &#34;&#34;&#34;
        Checks for input of the player and reacts adequately
        Because of all the animations it doesn&#39;t call functions but sets event variables
        &#34;&#34;&#34;
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                exit()
            elif event.type == pygame.KEYDOWN:
                if not self.game_running:
                    self.game_running = True
                    self.initialise_game()
            # 2nd and 3rd condition are disabling few animations onging at one moment
            elif event.type == pygame.MOUSEBUTTONDOWN and not self.raft_animation and not self.animated_figure:
                # player not allowed to control game when its not started
                if not self.game_running:
                    return
                if self.raft_rect.collidepoint(event.pos) and self.raft_count &gt;= 1:
                    self.raft_animation = True
                    self.calculate_direction()

                    continue
                for figure in self.cannibals+self.missionaries:
                    if figure[&#34;rect&#34;].collidepoint(event.pos) and\
                        alg.split_position(self.position)[2] == figure[&#34;side&#34;] and\
                            not self.animated_figure:
                        self.animated_figure = figure
                        self.calculate_velocity()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="main.Controller.animate_raft"><code class="name flex">
<span>def <span class="ident">animate_raft</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Animate raft and objects on it aka raft crew</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def animate_raft(self):
    &#34;&#34;&#34;
    Animate raft and objects on it aka raft crew
    &#34;&#34;&#34;
    # when the expression reaches 0 it means the raft came to the right place
    if self.direction * (RAFT_POSITIONS[self.opposite_index][0]-self.raft_rect.x) &gt; 0:
        self.raft_rect.x += self.direction * RAFT_SPEED
        for figure in self.raft_crew:
            figure[&#34;rect&#34;].x += self.direction * RAFT_SPEED
    else:
        # raft on the other side
        # stop animation and update position
        self.raft_rect.x = RAFT_POSITIONS[self.opposite_index][0]
        self.raft_animation = False
        # as raft reached other side it can be considered as move completion
        self.update_position()</code></pre>
</details>
</dd>
<dt id="main.Controller.calculate_direction"><code class="name flex">
<span>def <span class="ident">calculate_direction</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get current position of the raft and its side
And calculate the direction of movement of the raft</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_direction(self):
    &#34;&#34;&#34;
    Get current position of the raft and its side
    And calculate the direction of movement of the raft
    &#34;&#34;&#34;
    sign = alg.split_position(self.position)[2]
    if sign == &#34;&lt;&#34;:
        self.side_index = 0
    else:
        self.side_index = 1
    self.opposite_index = 1-self.side_index
    self.direction = self.opposite_index - self.side_index</code></pre>
</details>
</dd>
<dt id="main.Controller.calculate_velocity"><code class="name flex">
<span>def <span class="ident">calculate_velocity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate new position of each figure after changing place
And the speed it needs to maintain to reach the position in
certain number of frames (ANIMATION_STEPS)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_velocity(self):
    &#34;&#34;&#34;
    Calculate new position of each figure after changing place
    And the speed it needs to maintain to reach the position in
    certain number of frames (ANIMATION_STEPS)
    &#34;&#34;&#34;
    # calculate position when figure is reqiestered as raft crew
    if self.animated_figure[&#34;state&#34;] == &#34;raft&#34;:
        new_left, new_bottom = self.rand_not_colliding_rect(alg.split_position(self.position)[2]).bottomleft
    else:
        crew_xs = [x[&#34;rect&#34;].left for x in self.raft_crew]
        # take first empty place on the raft
        for i in range(RAFT_CAPACITY):
            new_left = self.raft_rect.left + i * CANNIBAL.get_width()
            if new_left not in crew_xs:
                break
        new_bottom = self.raft_rect.bottom
    # derivates of velocities
    self.dx = (new_left-self.animated_figure[&#34;rect&#34;].left)/ANIMATION_STEPS
    self.dy = (new_bottom-self.animated_figure[&#34;rect&#34;].bottom)/ANIMATION_STEPS
    self.animation_step = 0
    # dx and dy are often &lt; 1 and wouldn&#39;t be registered when assigned to rect
    # so 3rd variable of float type is used to store actual position
    self.animated_figure_x, self.animated_figure_y = self.animated_figure[&#34;rect&#34;].bottomleft</code></pre>
</details>
</dd>
<dt id="main.Controller.check_events"><code class="name flex">
<span>def <span class="ident">check_events</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks for input of the player and reacts adequately
Because of all the animations it doesn't call functions but sets event variables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_events(self):
    &#34;&#34;&#34;
    Checks for input of the player and reacts adequately
    Because of all the animations it doesn&#39;t call functions but sets event variables
    &#34;&#34;&#34;
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            exit()
        elif event.type == pygame.KEYDOWN:
            if not self.game_running:
                self.game_running = True
                self.initialise_game()
        # 2nd and 3rd condition are disabling few animations onging at one moment
        elif event.type == pygame.MOUSEBUTTONDOWN and not self.raft_animation and not self.animated_figure:
            # player not allowed to control game when its not started
            if not self.game_running:
                return
            if self.raft_rect.collidepoint(event.pos) and self.raft_count &gt;= 1:
                self.raft_animation = True
                self.calculate_direction()

                continue
            for figure in self.cannibals+self.missionaries:
                if figure[&#34;rect&#34;].collidepoint(event.pos) and\
                    alg.split_position(self.position)[2] == figure[&#34;side&#34;] and\
                        not self.animated_figure:
                    self.animated_figure = figure
                    self.calculate_velocity()</code></pre>
</details>
</dd>
<dt id="main.Controller.get_raft_position"><code class="name flex">
<span>def <span class="ident">get_raft_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get raft destination position according to side</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_raft_position(self):
    &#34;&#34;&#34;
    Get raft destination position according to side
    &#34;&#34;&#34;
    sign = alg.split_position(self.position)[2]

    if sign == &#34;&lt;&#34;:
        return RAFT_POSITIONS[0]
    return RAFT_POSITIONS[1]</code></pre>
</details>
</dd>
<dt id="main.Controller.initialise_game"><code class="name flex">
<span>def <span class="ident">initialise_game</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create / reset neccessary basic attributes of the game</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialise_game(self):
    &#34;&#34;&#34;
    Create / reset neccessary basic attributes of the game
    &#34;&#34;&#34;
    self.position = alg.starting
    self.win = None
    self.cannibals, self.missionaries = [], []
    for _ in range(CHARACTERS_NUMBER):
        self.cannibals.append({
            &#34;rect&#34;: self.rand_not_colliding_rect(STARTING_SIDE),
            &#34;type&#34;: &#34;c&#34;,
            &#34;side&#34;: STARTING_SIDE,
            &#34;state&#34;: &#34;edge&#34;
        })
        self.missionaries.append({
            &#34;rect&#34;: self.rand_not_colliding_rect(STARTING_SIDE),
            &#34;type&#34;: &#34;m&#34;,
            &#34;side&#34;: STARTING_SIDE,
            &#34;state&#34;: &#34;edge&#34;
        })
    self.raft_rect = RAFT.get_rect(topleft=self.get_raft_position())
    self.raft_count = 0
    self.raft_crew = []
    self.minimum_moves = min([len(x) for x in alg.find_path(self.position, [self.position], alg.winning)])-1
    self.moves_count = -1
    self.update_hint()</code></pre>
</details>
</dd>
<dt id="main.Controller.rand_not_colliding_rect"><code class="name flex">
<span>def <span class="ident">rand_not_colliding_rect</span></span>(<span>self, side)</span>
</code></dt>
<dd>
<div class="desc"><p>Rand a position on adequate side of the river which isn't occupied by other figure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rand_not_colliding_rect(self, side):
    &#34;&#34;&#34;
    Rand a position on adequate side of the river which isn&#39;t occupied by other figure
    &#34;&#34;&#34;
    width, height = CANNIBAL.get_width(), MISSIONARY.get_height()
    if side == &#34;&lt;&#34;:
        xs = [i*width for i in range(LEFT_WIDTH//width)]
        ys = [SCREEN_HEIGHT-LEFT_HEIGHT+i*height for i in range(LEFT_HEIGHT//height)]
    else:
        xs = [SCREEN_WIDTH-RIGHT_WIDTH+i*width for i in range(RIGHT_WIDTH//width)]
        ys = [SCREEN_HEIGHT-RIGHT_HEIGHT+i*height for i in range(RIGHT_HEIGHT//height)]
    # missionary is higher than cannibal
    # cannibal is wider than missionary
    new_rect = pygame.Rect(choice(xs), choice(ys), CANNIBAL.get_width(), MISSIONARY.get_height())
    while new_rect.collidelist([x[&#34;rect&#34;] for x in self.cannibals+self.missionaries]) &gt;= 0:
        new_rect.topleft = (choice(xs), choice(ys))
    return new_rect</code></pre>
</details>
</dd>
<dt id="main.Controller.transfer_figure"><code class="name flex">
<span>def <span class="ident">transfer_figure</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to animate each figure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transfer_figure(self):
    &#34;&#34;&#34;
    Function to animate each figure
    &#34;&#34;&#34;
    # limit of slots on the raft
    if self.raft_count &gt;= RAFT_CAPACITY and\
            self.animated_figure not in self.raft_crew:
        self.animated_figure = None
        return
    # animation came to an end
    if self.animation_step == ANIMATION_STEPS:
        # figure switches from side to raft
        if self.animated_figure[&#34;state&#34;] == &#34;edge&#34;:
            self.animated_figure[&#34;state&#34;] = &#34;raft&#34;
            self.raft_crew.append(self.animated_figure)
            self.raft_count += 1
        # antagonistic case
        else:
            self.animated_figure[&#34;state&#34;] = &#34;edge&#34;
            self.raft_crew.remove(self.animated_figure)
            self.raft_count -= 1
        self.animated_figure = None
        return

    self.animated_figure_x += self.dx
    self.animated_figure_y += self.dy
    self.animated_figure[&#34;rect&#34;].bottomleft = (self.animated_figure_x, self.animated_figure_y)
    self.animation_step += 1</code></pre>
</details>
</dd>
<dt id="main.Controller.update_hint"><code class="name flex">
<span>def <span class="ident">update_hint</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update counter of moves, check the current minimum according to new path
and render new text with the resulting value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_hint(self):
    &#34;&#34;&#34;
    Update counter of moves, check the current minimum according to new path
    and render new text with the resulting value
    &#34;&#34;&#34;
    self.moves_count += 1
    currrent_min_moves = min([len(x) for x in alg.find_path(self.position, [self.position], alg.winning)])-1
    self.moves_render = FONT.render(HINT_TEXT.format(currrent_min_moves), True, TEXT_COLOR)</code></pre>
</details>
</dd>
<dt id="main.Controller.update_position"><code class="name flex">
<span>def <span class="ident">update_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates position after move is completed, checks for victory or lose
and takes care of updating hint text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_position(self):
    &#34;&#34;&#34;
    Updates position after move is completed, checks for victory or lose
    and takes care of updating hint text
    &#34;&#34;&#34;
    raft_crew_types = [x[&#34;type&#34;] for x in self.raft_crew]
    raft_string = &#39;&#39;.join(sorted(raft_crew_types))
    self.position = alg.get_resulting_position(self.position, raft_string)
    new_sign = alg.split_position(self.position)[2]
    for figure in self.raft_crew:
        figure[&#34;side&#34;] = new_sign
    if self.position == alg.winning:
        self.win = True
        self.game_running = False
        self.moves_count += 1
        self.moves_render = FONT.render(FINAL_TEXT.format(self.moves_count, self.minimum_moves), True, TEXT_COLOR)
        return
    elif self.position in alg.losing:
        self.win = False
        self.game_running = False
        self.moves_count += 1
        self.moves_render = FONT.render(FINAL_TEXT.format(self.moves_count, self.minimum_moves), True, TEXT_COLOR)
        return
    self.update_hint()</code></pre>
</details>
</dd>
<dt id="main.Controller.update_screen"><code class="name flex">
<span>def <span class="ident">update_screen</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Display objects according to current phase of the game</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_screen(self):
    &#34;&#34;&#34;
    Display objects according to current phase of the game
    &#34;&#34;&#34;
    self.screen.blit(BACKGROUND, BACKGROUND.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2)))
    if self.game_running:
        if self.raft_animation:
            self.animate_raft()
        if self.animated_figure:
            self.transfer_figure()
        for i in range(CHARACTERS_NUMBER):
            self.screen.blit(CANNIBAL, self.cannibals[i][&#34;rect&#34;])
            self.screen.blit(MISSIONARY, self.missionaries[i][&#34;rect&#34;])
        self.screen.blit(RAFT, self.raft_rect)
        self.screen.blit(self.moves_render, self.moves_render.get_rect(center=(SCREEN_WIDTH//2, 50)))
    else:
        # game not started
        if not isinstance(self.win, bool):
            self.screen.blit(STARTING_TEXT, STARTING_TEXT.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2)))
        else:
            # game won
            if self.win:
                self.screen.blit(WIN_TEXT, WIN_TEXT.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2)))
            # game lost
            else:
                self.screen.blit(LOSING_TEXT, LOSING_TEXT.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2)))
            self.screen.blit(self.moves_render, self.moves_render.get_rect(center=(SCREEN_WIDTH//2, 50)))
    pygame.display.flip()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="main.run_game" href="#main.run_game">run_game</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="main.Controller" href="#main.Controller">Controller</a></code></h4>
<ul class="">
<li><code><a title="main.Controller.animate_raft" href="#main.Controller.animate_raft">animate_raft</a></code></li>
<li><code><a title="main.Controller.calculate_direction" href="#main.Controller.calculate_direction">calculate_direction</a></code></li>
<li><code><a title="main.Controller.calculate_velocity" href="#main.Controller.calculate_velocity">calculate_velocity</a></code></li>
<li><code><a title="main.Controller.check_events" href="#main.Controller.check_events">check_events</a></code></li>
<li><code><a title="main.Controller.get_raft_position" href="#main.Controller.get_raft_position">get_raft_position</a></code></li>
<li><code><a title="main.Controller.initialise_game" href="#main.Controller.initialise_game">initialise_game</a></code></li>
<li><code><a title="main.Controller.rand_not_colliding_rect" href="#main.Controller.rand_not_colliding_rect">rand_not_colliding_rect</a></code></li>
<li><code><a title="main.Controller.transfer_figure" href="#main.Controller.transfer_figure">transfer_figure</a></code></li>
<li><code><a title="main.Controller.update_hint" href="#main.Controller.update_hint">update_hint</a></code></li>
<li><code><a title="main.Controller.update_position" href="#main.Controller.update_position">update_position</a></code></li>
<li><code><a title="main.Controller.update_screen" href="#main.Controller.update_screen">update_screen</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>